/*observation
1 search if cache existing data
2 latest use in the end
3 least use in the first
4 remove least use(first) when exeeds size
5 if an existing one is used, update it to lastest use(in the end), and remove it from origin position
6 if put an existing key, we'd better to remove the old one and create and put the new one. Because the value of key could be updated. if not use the new node, do not forget update the value
*/
class LRUCache {
    Map<Integer, Node> map;
    DoubleLinkedList list;
    int size;
    public LRUCache(int capacity) {
        map = new HashMap<>();
        list = new DoubleLinkedList();
        size = capacity;
    }
    
    public int get(int key) {
        if(map.containsKey(key)) {
            Node node = map.get(key);
            list.removeNode(node);
            list.addToLast(node);
            
            return node.val;
        }
        
        return -1;
    }
    
    public void put(int key, int value) {
        Node newNode = new Node(key, value);
        if(map.containsKey(key)) {
            Node node = map.get(key);
            list.removeNode(node);
            map.remove(key);
        } else {
            if(size == map.size()) {
                int removedKey = list.removeFirst();
                map.remove(removedKey);             
            }
        }
        map.put(key, newNode);
        list.addToLast(newNode);
    }
}

class DoubleLinkedList {
    Node head;
    Node tail;
    
    public DoubleLinkedList() {
        head = new Node(-1, -1);
        tail = new Node(-1, -1);
        head.next = tail;
        tail.prev = head;
    }
    
    public void addToLast(Node node) {
        tail.prev.next = node;
        node.prev = tail.prev;
        node.next = tail;
        tail.prev = node;
    }
    
    public void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
        node.prev = null;
        node.next = null;
    }
    
    public int removeFirst() {
        Node node = head.next;
        head.next = node.next;
        node.next.prev = head;
        node.prev = null;
        node.next = null;
        
        return node.key;
    }
}

class Node {
    int key;
    int val;
    Node prev;
    Node next;
    
    public Node(int key, int val) {
        this.key = key;
        this.val = val;
    }
}

/**
class LRUCache {
    LinkedHashMap<Integer, Integer> cache;
    int size;
    public LRUCache(int capacity) {
        cache = new LinkedHashMap<>();
        size = capacity;
    }
    
    public int get(int key) {
        if(!cache.containsKey(key)) return -1;
        
        int val = cache.get(key);
        cache.remove(key);
        cache.put(key, val);
        
        return val;
    }
    
    public void put(int key, int value) {
        if(!cache.containsKey(key)) {
            if(cache.size() == size) {
                int firstKey = cache.keySet().iterator().next();
                cache.remove(firstKey);
            }
        } else {
            cache.remove(key);
        }
        cache.put(key, value);
    }
}

 */